#!/usr/bin/env bash

# LLM Environment Management Tool v2
# Uses symlinks to dynamically rendered templates for always-fresh configuration

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LLMENV_ROOT="$(dirname "$SCRIPT_DIR")"

# Configuration
CLAUDE_DIR="$HOME/.claude"
CURSOR_RULES_DIR=".cursor/rules"
RENDERED_DIR="$LLMENV_ROOT/rendered"

# Scripts
RENDER_SCRIPT="$LLMENV_ROOT/scripts/render-template.sh"
INSTALL_MANAGER="$LLMENV_ROOT/scripts/installation-manager.sh"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Utility functions
log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Show usage
show_usage() {
    cat << EOF
LLM Environment Management Tool v2 (Symlink + Dynamic Rendering)

Usage: llmenv <command> [options]

Commands:
  install [language]    Install base configuration or language-specific rules
  uninstall [language]  Remove configuration or language-specific rules
  sync                  Regenerate all rendered templates (updates existing installs)
  list                  List available languages and current installations
  status               Show current configuration status
  help                 Show this help message

Examples:
  llmenv install           # Install base configuration for all tools
  llmenv install ruby      # Install Ruby-specific rules
  llmenv install typescript react  # Install multiple language rules
  llmenv sync              # Update all existing installations with latest templates
  llmenv uninstall ruby   # Remove Ruby-specific rules
  llmenv list             # Show available languages
  llmenv status           # Show current setup

Features:
  - Always-fresh templates via symlinks to dynamically rendered files
  - Easy updates with 'sync' command
  - Automatic fallback to copying if symlinks not supported
  - Installation tracking for easy management

Supported Languages:
  ruby, typescript, react, terraform

Supported Tools:
  - Claude (global ~/.claude/CLAUDE.md)
  - Cursor (project-local .cursor/rules/)
EOF
}

# Create directory if it doesn't exist
ensure_dir() {
    local dir="$1"
    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir"
        log_info "Created directory: $dir"
    fi
}

# Test if symlinks are supported in a directory
test_symlink_support() {
    local target_dir="$1"
    local test_file="$target_dir/.llmenv-symlink-test"
    local test_link="$target_dir/.llmenv-symlink-test-link"
    
    # Create test file
    echo "test" > "$test_file"
    
    # Try to create symlink
    if ln -s "$test_file" "$test_link" 2>/dev/null; then
        # Cleanup and return success
        rm -f "$test_file" "$test_link"
        return 0
    else
        # Cleanup and return failure
        rm -f "$test_file" "$test_link"
        return 1
    fi
}

# Render a template with specified languages
render_template() {
    local template_file="$1"
    local output_file="$2"
    shift 2
    local languages=("$@")
    
    ensure_dir "$(dirname "$output_file")"
    
    "$RENDER_SCRIPT" "$template_file" "${languages[@]}" > "$output_file"
    log_info "Rendered template: $output_file"
}

# Create symlink or copy as fallback
link_or_copy() {
    local source="$1"
    local target="$2"
    local description="$3"
    
    ensure_dir "$(dirname "$target")"
    
    # Remove existing file/link
    if [[ -e "$target" ]] || [[ -L "$target" ]]; then
        rm "$target"
    fi
    
    # Try symlink first
    if test_symlink_support "$(dirname "$target")"; then
        ln -s "$source" "$target"
        log_info "Symlinked $description: $target -> $source"
    else
        cp "$source" "$target"
        log_warn "Copied $description (symlinks not supported): $target"
    fi
}

# Regenerate all rendered templates
regenerate_rendered() {
    log_info "Regenerating all rendered templates..."
    
    # Regenerate Claude if installed
    local claude_languages=($("$INSTALL_MANAGER" languages claude 2>/dev/null || echo ""))
    if [[ ${#claude_languages[@]} -gt 0 ]] || "$INSTALL_MANAGER" get claude >/dev/null 2>&1; then
        render_template "$LLMENV_ROOT/templates/claude/CLAUDE.md" "$RENDERED_DIR/claude/CLAUDE.md" "${claude_languages[@]}"
        log_info "Regenerated Claude configuration"
    fi
    
    # Regenerate Cursor if installed
    local cursor_languages=($("$INSTALL_MANAGER" languages cursor 2>/dev/null || echo ""))
    if [[ ${#cursor_languages[@]} -gt 0 ]] || "$INSTALL_MANAGER" get cursor >/dev/null 2>&1; then
        render_template "$LLMENV_ROOT/templates/cursor/rules.md" "$RENDERED_DIR/cursor/rules.md" "${cursor_languages[@]}"
        log_info "Regenerated Cursor rules"
    fi
    
    log_info "Template regeneration complete!"
}

# Install base configuration
install_base() {
    log_info "Installing base LLM environment configuration..."
    
    # Render and install Claude configuration
    ensure_dir "$CLAUDE_DIR"
    render_template "$LLMENV_ROOT/templates/claude/CLAUDE.md" "$RENDERED_DIR/claude/CLAUDE.md"
    link_or_copy "$RENDERED_DIR/claude/CLAUDE.md" "$CLAUDE_DIR/CLAUDE.md" "Claude configuration"
    "$INSTALL_MANAGER" record claude "$CLAUDE_DIR/CLAUDE.md"
    
    log_info "Base configuration installed successfully!"
}

# Install language-specific rules
install_language() {
    local language="$1"
    local language_file="$LLMENV_ROOT/blocks/languages/$language.md"
    
    if [[ ! -f "$language_file" ]]; then
        log_error "Language '$language' not supported. Run 'llmenv list' to see available languages."
        return 1
    fi
    
    log_info "Installing $language rules..."
    
    # Update Claude configuration
    local claude_config="$CLAUDE_DIR/CLAUDE.md"
    if [[ -f "$claude_config" ]] || [[ -L "$claude_config" ]]; then
        # Get current languages and add new one
        local current_languages=($("$INSTALL_MANAGER" languages claude))
        local new_languages=("${current_languages[@]}" "$language")
        
        # Remove duplicates
        local unique_languages=($(printf '%s\n' "${new_languages[@]}" | sort -u))
        
        # Regenerate Claude config with new languages
        render_template "$LLMENV_ROOT/templates/claude/CLAUDE.md" "$RENDERED_DIR/claude/CLAUDE.md" "${unique_languages[@]}"
        "$INSTALL_MANAGER" record claude "$CLAUDE_DIR/CLAUDE.md" "${unique_languages[@]}"
        
        log_info "Updated Claude configuration with $language rules"
    fi
    
    # Install Cursor rules if in a project directory
    if [[ -d ".git" ]] || [[ -f "package.json" ]] || [[ -f "Gemfile" ]] || [[ -f "main.tf" ]]; then
        ensure_dir "$CURSOR_RULES_DIR"
        
        # Copy gitignore if it doesn't exist
        if [[ ! -f "$CURSOR_RULES_DIR/.gitignore" ]]; then
            cp "$LLMENV_ROOT/templates/cursor/.gitignore" "$CURSOR_RULES_DIR/"
            log_info "Added .gitignore to cursor rules directory"
        fi
        
        # Get current cursor languages and add new one
        local cursor_languages=($("$INSTALL_MANAGER" languages cursor 2>/dev/null || echo ""))
        local new_cursor_languages=("${cursor_languages[@]}" "$language")
        local unique_cursor_languages=($(printf '%s\n' "${new_cursor_languages[@]}" | sort -u))
        
        # Render and install Cursor rules
        render_template "$LLMENV_ROOT/templates/cursor/rules.md" "$RENDERED_DIR/cursor/rules.md" "${unique_cursor_languages[@]}"
        link_or_copy "$RENDERED_DIR/cursor/rules.md" "$CURSOR_RULES_DIR/rules.md" "Cursor rules"
        "$INSTALL_MANAGER" record cursor "$CURSOR_RULES_DIR/rules.md" "${unique_cursor_languages[@]}"
        
        log_info "Installed $language rules for Cursor"
    fi
    
    log_info "$language rules installed successfully!"
}

# Install command handler
cmd_install() {
    if [[ $# -eq 0 ]]; then
        install_base
    else
        # Install base first if it doesn't exist
        if [[ ! -f "$CLAUDE_DIR/CLAUDE.md" ]] && [[ ! -L "$CLAUDE_DIR/CLAUDE.md" ]]; then
            install_base
        fi
        
        # Install each language specified
        for language in "$@"; do
            install_language "$language"
        done
    fi
}

# Sync command - regenerate all templates
cmd_sync() {
    log_info "Syncing all LLM environment configurations..."
    regenerate_rendered
    log_info "All configurations synced successfully!"
}

# List available languages
cmd_list() {
    echo "Available languages:"
    for lang_file in "$LLMENV_ROOT/blocks/languages"/*.md; do
        if [[ -f "$lang_file" ]]; then
            local lang_name="$(basename "$lang_file" .md)"
            echo "  - $lang_name"
        fi
    done
    
    echo ""
    echo "Current installations:"
    
    local installations=$("$INSTALL_MANAGER" list)
    if [[ -n "$installations" ]]; then
        echo "$installations" | sed 's/^/  /'
    else
        echo "  No installations found"
    fi
}

# Show status
cmd_status() {
    echo "LLM Environment Status (v2 - Symlink + Dynamic Rendering)"
    echo "==========================================================="
    echo ""
    
    echo "LLMENV_ROOT: $LLMENV_ROOT"
    echo "Rendered templates: $RENDERED_DIR"
    echo "Claude config: $CLAUDE_DIR/CLAUDE.md"
    echo "Cursor rules: $CURSOR_RULES_DIR"
    echo ""
    
    # Check if rendered directory exists and show status
    if [[ -d "$RENDERED_DIR" ]]; then
        echo "Rendered templates:"
        find "$RENDERED_DIR" -name "*.md" | sed 's|^.*/|  |'
    else
        echo "No rendered templates found"
    fi
    echo ""
    
    cmd_list
}

# Main command dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 1
    fi
    
    case "$1" in
        install)
            shift
            cmd_install "$@"
            ;;
        uninstall)
            shift
            log_warn "Uninstall command not yet implemented"
            exit 1
            ;;
        sync)
            cmd_sync
            ;;
        list)
            cmd_list
            ;;
        status)
            cmd_status
            ;;
        help|--help|-h)
            show_usage
            ;;
        *)
            log_error "Unknown command: $1"
            echo ""
            show_usage
            exit 1
            ;;
    esac
}

main "$@"